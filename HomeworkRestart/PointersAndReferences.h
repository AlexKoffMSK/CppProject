#pragma once
#include <iostream>

namespace PointersAndReferences
{
	void Test1()
	{
		int a = 3;
		int b = 6;

		//указатель:
		int* p = &a; //указатель на int имеет тот же тип данных, что и данные, на которые ссылается указатель

		*p = 4; //через указатель изменили значение переменной, на которую ссылается указатель

		p = &b;

		*p = 7;
		p = nullptr;

		//ссылки:

		int& r = a; //r - это ссылка на а

		r = 5; //меняется на сам r, а меняется то, куда r ссылается, т.е. - а

		// r = b; эта строка означает - записать то, куда смотрит r (на а) значением, которое живет в b (7). 
		// r = nullptr; //такое нельзя
		//ссылка всегда смотрит на один и тот же объект, ссылка не может смотреть в никуда, ссылку нельзя перевязать на новый объект
	}

	void Test2(int a)
	{
		std::cout << a << std::endl;
		a = 3;
	}

	void Test3(int* p)
	{
		std::cout << *p << std::endl; //печатает значение не самого указателя, а то - куда он смотрит
		*p = 4;
	}

	void Test4(int& r)
	{
		std::cout << r << std::endl; //печатает не ссылку, а то - куда она смотрит
		r = 5; //меняет не ссылку, а то - куда она смотрит
	}

	void Test5()
	{
		int a = 2;

		Test2(a);
		std::cout << a << std::endl;

		Test3(&a);
		std::cout << a << std::endl;

		Test4(a);
		std::cout << a << std::endl;
	}
	//Ссылка и указатель различаются тем, что:
	// 	   ссылка не может быть перевязана на новый объект, не может смотреть в никуда
	//	   при работе с сылками не используются & и *, когда нам надо объект изменить
	//	   над указателями можно проводить адресную арифметику, можно сдвинуть указатель, ссылку нельзя
	//	   у указателей есть - указатель на указатель. у ссылок такого нет. Но есть ссылка на указатель.
}
