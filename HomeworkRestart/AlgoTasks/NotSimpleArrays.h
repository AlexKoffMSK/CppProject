#pragma once

/*
Массивы
1. Симметричны ли значения элементов массива?
2. Переставить элементы массива в обратном порядке.
3. Циклически сдвинуть элементы массива на одну позицию вправо.
4. Сравнить два неупорядоченных целочисленных массива A и B как числовые множества: A = B и A принадлежит B.
5. Удалить из массива все отрицательные значения, а оставшиеся уплотнить (сдвинуть) с сохранение исходного порядка к началу массива.
6. Циклически сдвинуть элементы массива на K позиций вправо с затратой O(N)действий (N-длина массива)
7. Каждый элемент массива заменить на полусумму соседей (кроме первого и последнего)
8. Назовем x-отрезком группу подряд идущих элементов массива, каждый из которых равен x. 
Для заданного числа x заменить элементы каждого x-отрезка на полусумму элементов, прилегающих к этому отрезку справа и слева. 
Если x-отрезок расположен в начале или конце массива, считать недостающий крайний элемент равным нулю.
9. Сгруппировать положительные элементы массива в его начале, а отрицательные - в конце с сохранением их порядка.
10. Получить массив биномиальных коэффициентов для степени N, последовательно вычисляя строки треугольника Паскаля (можно использовать только один массив).
11. Элементы массива не убывают. Двоичным поиском определить позицию, где в этот массив можно вставить данное число x.
12. Даны два неубывающих массива. Построить третий неубывающий массив, который является объединением первых двух.
13. Пусть в массиве последовательно записаны цифры некоторого длинного десятичного числа. 
Реализовать функции "прибавляющие единицу"и "вычитающие единицу"из такого числа.
14. Удалить все элементы массива с четными значениями, уплотнив массив к его началу.Функция должна возвращать количество элементов в получившемся массиве.
15. Заменить все локальные минимумы в массиве одним элементом, значение которого равно элементумассива с минимальным значением. 
Функция должна возвращать количество элементов в получившемся массиве.
16. Заменить каждый элемент массива количеством элементов массива с меньшими индексами, имеющими значение, меньше данного элемента, 
т.е. каждый элемент массива ai заменить количеством элеметвом массива aj , таких что j < i и aj < ai.
17. Отнормировать все элементы массива {ai}i=1,...,N на интервал [min(a1, aN), max(a1, aN)], т.е. в случае, когда все элементы массива совпадают, 
изменять массив не следует, иначе заменить каждый элемент массива на значение min(a1, aN) + [(ai − min(a1, aN))/|a1 − aN|].
18. Заменить все минимальные элементы массива на значение элемента массива, большего минимального, но не большего всех остальных элементов массива.
19. Удалить из массива наиболее часто встречающееся значение. Если таких значений несколько, то выбрать любое из них. 
Функция должна возвращать количество элементов в получившемся массиве.
20. Удалить из массива наименее часто встречающееся значение. Если таких значений несколько, то удалить все эти значения. 
Функция должна возвращать количество элементов в получившемся массиве.
21. В каждом интервале строгого возрастания в массиве заменить все значения в данном интервале на среднее значение в 
интервале (рассматриваются интервалы возрастания в массиве, которые нельзя удлинить).
22. Поменять местами в массиве локальные минимумы с соседними порядковыми номерами, т.е. поменять местами в массиве локальные минимумы с 
номерами 2i и 2i + 1 для всех возможных i.
23. Удалить из массива элементы, содержащиеся во всех интервалах строгого возрастания с длиной не более 3. 
Функция должна возвращать количество элементов в получившемся массиве.
24.
*/

namespace AlgoTasks::NotSimpleArrays
{
	void Task3()
	{
		std::vector<int> vec = { 1,2,3,4,5,6,7,8,9 };

		int back_up = vec.back();

		for (int i=vec.size()-1; i>0; --i)
		{
			vec[i] = vec[i - 1];
		}
		vec[0] = back_up;

		for (auto e : vec)
		{
			std::cout << e << ' ';
		}
	}

	std::vector<int> GetUniqueElems(std::vector<int> arr)
	{
		std::sort(arr.begin(), arr.end());
		
		std::vector<int> res_vec;
		
		res_vec.push_back(arr[0]);

		for (int i = 1; i < arr.size(); ++i)
		{
			if (arr[i] != res_vec.back())
			{
				res_vec.push_back(arr[i]);
			}
		}
		return res_vec;
	}
	
	bool IsArray1ContainsInArray2(std::vector<int> arr1, std::vector<int> arr2)
	{
		if (arr1.size() > arr2.size())
		{
			return false;
		}

		for (int i = 0; i < arr1.size(); ++i)
		{
			if (std::find(arr2.begin(), arr2.end(), arr1[i]) == arr2.end())
			{
				return false;
			}
		}
		return true;

	}

	//4. Сравнить два неупорядоченных целочисленных массива A и B как числовые множества: A = B и A принадлежит B.
	void Task4()
	{
		//1 2 3 1 1 2 3 3 - A
		//1 2 3 - B
		//A = B

		//1 2 3 1 1 2 3 3 - A
		//2 3 4 - B
		//A != B

		//1 2 3 1 1 2 3 3 - A
		//1 2 3 4 - B
		//A принадлежит B (A c B)

		//1 2 3 1 1 2 3 3 - A
		//2 1 3 - A`
		//3 2 1 - B
		//A = B

		std::vector<int> or_vec = { 2,3,1,0,3,4,5 };
		std::vector<int> or_vec1 = { 0,0,1,6,3,4,5 };
		
		std::vector<int> vec = GetUniqueElems(or_vec);
		std::vector<int> vec1 = GetUniqueElems(or_vec1);

		if (vec.size() == vec1.size())
		{
			for (int i = 0; i < vec.size(); ++i)
			{
				if (vec[i] != vec1[i])
				{
					std::cout << "Not Equal" << std::endl;
					return;
				}
			}
			std::cout << "Equal" << std::endl;
		}
		else
		{
			if (IsArray1ContainsInArray2(vec, vec1))
			{
				std::cout << "Not Equal & Arr 1 contains in Arr2" << std::endl;
			}
			else
			{
				std::cout << "Not Equal & Arr 1 do not contains in Arr2" << std::endl;
			}
		}
	}
}