#pragma once
#include <iostream>

namespace BitOperationsBasic
{
	void Test1()
	{
		//int - 4 байта, целое число, знаковое
		//unsigned int -  4 байта, целое число, беззнаковое
		//long - 8 байт, целое число, знаковое
		//unsigned long -  8 байт, целое число, беззнаковое
		//short - 2 байта, целое число, знаковое
		//unsigned short - 2 байта, целое число, беззнаковое
		//float - 4 байта, число со значением после запятой (десятичное), знаковое
		//double - 8 байт, число со значением после запятой (десятичное), знаковое
		//char - 1 байт, целое число, знаковое (может иметь отрицательные значения!)
		//unsigned char - 1 байт, целое число, беззнаковое
		//
		//int8_t - 1 байт, целое, знаковое, аналог char
		//uint8_t - 1 байт, целое, беззнаковое, аналог unsigned char
		//int16_t, int32_t, int64_t и uint16_t...
		
		char z = -3;
		//1000 0011 - прямой код
		//1111 1100 - обратный код
		//0000 0001 = 1;
		//1111 1101 - дополнительный код числа (-3) = обратный + 1
		
		//как получить представление -1 в дополнительном коде:
		//1000 0001 прямой код
		//1111 1110 обратный код
		//0000 0001 прибавляем единицу к обратному коду столбиком
		//1111 1111 = дополнительный код
		
		int a = 3;
		std::cout << a << std::endl;
		std::cout << std::bitset<8>(a) << std::endl;

		int b = a << 1; //это означает, что в b засунется число, которое равно числу a, у которого все биты сдвинуты на 1 позицию налево
		//a = 0000 0011
		//a << 1 = 0000 0110
		//b = 0000 0110 = 6 
		std::cout << b << std::endl;
		std::cout << std::bitset<8>(b) << std::endl;

		int c = a << 2;
		//a = 0000 0011
		//a << 2 = 0000 1100
		//c = 0000 1100 = 12 
		std::cout << c << std::endl;
		std::cout << std::bitset<8>(c) << std::endl;

		int d = a >> 1;
		//a = 0000 0011
		//a >> 1 = 0000 0001
		//d = 0000 0001 = 1 
		std::cout << d << std::endl;
		std::cout << std::bitset<8>(d) << std::endl;
	}

	void Test2()
	{
		//0000 0001 =  1
		//0000 0010 =  2
		//0000 0100 =  4
		//0000 1000 =  8
		//0001 0000 = 16
		//Если в бинарном представлении положительного числа ровно одна единица - значит это степень двойки.

		//0001 1000 = 24
		//0000 1100 = 12
		//0000 0110 =  6
		//0000 0011 =  3
		//0000 0001 =  1
		//сдвиг налево на 1 позицию - это умножение на 2, сдвиг направо на 1 позицию - это деление на 2

		//битовые сдвиги - быстрее, чем арифметическое деление
	}

	void Test3() 
	{
		int a = 3;  // 0000 0011
		int b = 10; // 0000 1010
		//побитовое И - это бинарная операция
		// 0000 0011 
		// 0000 1010
		
		// Операция И - конъюнкция
		// 0 & 0 = 0
		// 0 & 1 = 0
		// 1 & 0 = 0
		// 1 & 1 = 1
		// Если хотя бы один из операндов 0, то результат 0
		
		// a & b - один амперсанд - побитовое И, два амперсанда - логическое И
		// 0000 0011 
		// 0000 1010
		// 0000 0010 = 2
		int c = a & b;
		std::cout << c << std::endl;
		std::cout << std::bitset<8>(c) << std::endl;

		// Операция ИЛИ - дизъюнкция
		// 0 | 0 = 0
		// 0 | 1 = 1
		// 1 | 0 = 1
		// 1 | 1 = 1
		// Если хотя бы один из операндов 1, то результат 1

		// a | b
		// 0000 0011 
		// 0000 1010
		// 0000 1011 = 11
		int d = a | b;
		std::cout << d << std::endl;
		std::cout << std::bitset<8>(d) << std::endl;

		// Исключающее ИЛИ - строгая дизъюнкция (xor)
		// 0 ^ 0 = 0
		// 0 ^ 1 = 1
		// 1 ^ 0 = 1
		// 1 ^ 1 = 0
		// Если хотя бы один из операндов 1, то результат 1, но если оба 1 - то результат 0.
		
		// a ^ b
		// 0000 0011 
		// 0000 1010
		// 0000 1001 = 9
		int e = a ^ b;
		std::cout << e << std::endl;
		std::cout << std::bitset<8>(e) << std::endl;
	}

	void Test4()
	{
		int a = 3;
		int b = ~a;
		// ~ - тильда это операция побитового отрицания числа a, все биты инвертируются
		std::cout << b << std::endl;
		std::cout << std::bitset<8>(b) << std::endl;
	}
	
	// функция числу а в бит под номером bit_pos поставит 1
	// a = 10, bit_pos = 3, bit_value = 1
	// 0000 1010 -> 0000 1110
	// a = 10, bit_pos = 2, bit_value = 0
	// 0000 1010 -> 0000 1000
	int Set1ToBit(int a, int bit_pos)
	{
		//assert(bit_value == 0 || bit_value == 1);
		//поставить в третий бит единицу
		//a = 10
		//0000 1010
		//0000 0100 (1 (0000 0001) << 2)
		//0000 0001
		//a = a | (1 << 2);
		//x | 0 = x; - ИЛИ 0 ничего не меняет
		//x | 1 = 1; - ИЛИ 1 всегда дает 1
		return a | (1 << bit_pos);
	}

	int Set0ToBit(int a, int bit_pos)
	{
		//a =		0000 1010
		//			1111 1101
		//result =  0000 1000
		//x & 0 = 0; - И 0 всегда дает 0 - можно понимать как умножение
		//x & 1 = x; - И 1 ничего не меняет - можно понимать как умножение
		return a & ~(1 << bit_pos);
		//bit_pos = 0, ~(1 << bit_pos) = ~(1 << 0) = ~((0000 0001) << 0) = ~(0000 0001) = (1111 1110)
		//bit_pos = 1, ~(1 << bit_pos) = ~(1 << 1) = ~((0000 0001) << 1) = ~(0000 0010) = (1111 1101)
	}

	void TestDel()
	{
		std::cout << bitset<8>(1);
		std::cout << bitset<8>(1 << 1);
		std::cout << bitset<8>(1 << 5);
		std::cout << bitset<8>(1 << 27);
	}
	/*
	1111 1101 ~(1 << bit_pos)
	0000 0001
	0000 0010 (1 << bit_pos)
	0001 0000
	*/
	void TestSetBits()
	{
		int a = 10;
		std::cout << std::bitset<8>(a) << std::endl;
		std::cout << std::bitset<8>(Set0ToBit(a, 0)) << std::endl;
		std::cout << std::bitset<8>(Set0ToBit(a, 1)) << std::endl;
		std::cout << std::bitset<8>(Set0ToBit(a, 2)) << std::endl;
		std::cout << std::bitset<8>(Set0ToBit(a, 3)) << std::endl;

		std::cout << std::bitset<8>(Set1ToBit(a, 0)) << std::endl;
		std::cout << std::bitset<8>(Set1ToBit(a, 1)) << std::endl;
		std::cout << std::bitset<8>(Set1ToBit(a, 2)) << std::endl;
		std::cout << std::bitset<8>(Set1ToBit(a, 3)) << std::endl;

	}

	bool IsBitOnBitPosEquals1(int a, int bit_pos)
	{
		// a1 =		0000 1010
		// a2 =		0000 1011
		// 
		// m =		0000 0001
		// 
		// a1&m =	0000 0000
		// a2&m =	0000 0001
		// 
		// bit_pos = 0; result = false
		 
		//int mask = Set1ToBit(0, bit_pos);
		int mask = (1 << bit_pos);
		//return ((a & (1 << bit_pos)) != 0);
		return ((a & mask) != 0);
	}

	bool IsBitOnBitPosEquals0(int a, int bit_pos)
	{
		int mask = (1 << bit_pos);
		return ((a & mask) == 0);
	}

	//bool IsPowerOf2(int a)
	//{
	//	//1,2,4,8,16,32,64...
	//	int counter = 0;
	//	for (int i = 0; i < sizeof(a) * 8; ++i)
	//	{
	//		if (IsBitOnBitPosEquals1(a, i))
	//		{
	//			counter++;
	//		}
	//	}
	//	return counter == 1;
	//}

	bool IsPowerOf2(int a)
	{
		//1,2,4,8,16,32,64...
		//0000 1000
		//0000 0111
		// 
		//0000 0110
		//0000 0101
		//0011 0110

		return (a & (a - 1) == 0);
	}

	//123
	//122
	//001
	
	//150
	//149
	//011

	//100
	//099
	//111

	// 0 & 0 = 0
	// 0 & 1 = 0
	// 1 & 0 = 0
	// 1 & 1 = 1












}